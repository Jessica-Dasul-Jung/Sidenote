emacs --version: shows you the version
-- to distinguish from -
-: lots of option
--: one option

ex) brew --version
  to check the version of the program

04/09/2018
Bash:
#!/bin/bash
./: current directory
if we do not specify the path, the terminal will search through path variables to find a match
relative path: ex) ./a.sh: try to execute the specify the program and run it
chmod 777 a.sh
./a.sh
bash script: directly run it
bash ./a.sh: specify it is bash (hassle) - just do #!/bin/bash

bash script:
# ls
# ls /

var=5; //how you assign a variable
var= 5; //space: it will fail: bash will think this is another argument of this command, variable called var=
echo (printf, cout)
echo $var; //to print
varr=$var; //assign variable to another variable
echo $varr
echo 5+1 //prints 5+1 (not 6)

var=5+1
echo $var //prints 5+1

var=5+1
echo $(5+1) //prints 5+1
echo $((5+1))// prints 6, or put the expression in var and print var
need to wrap calculation in $ and double parentheses
echo $((var+1)) //prints 7 if var=6

LAB 2
duplicates: contents are the same
file names under directory: ls
how do we check for reuglar file
creating a hard link: how to create a hard link - google

xml language: html

bash script: interpreting language



d
d


var="\$((5+1))"
echo var //prints $((5+1)) //backslash ignores $

var=ls;
echo var //prints ls

var='ls'
echo var //performs ls command

var=$(ls) //single bracket to wrap around command
echo $var

var='ls'
varr=$((1+1))
echo " $var is good $varr " //prints test2.txt (var command) is good 2 (varr variable)
backslash special character: ignores special property

echo " $var is good $varr"'kkjkj'" //prints test2.txt is good 2kkjkj
echo ' $var is good $varr '//dont

'ls' //still gives you teh output of ls, "ls" works the same


speical variables:
path variable: $
home variable

taking input from the command line:
echo $0 //exists in bash program, prints the name of the program
$0: gives you the first argument you put into the argument 
  could give you absolute path, or ./a.sh
./a.sh 100
echo $1 //represents second argument = first argument of the program - prints 100
cat $1
./a.sh text.txt
aaa
bbb
ccc

echo $# //how many arguments the user inputs - FINALFINALFINAL - does not include $0
./a.sh test.txt sdfsd
gives 2

./a.sh test.txt *
gives 14 (wildcard will put everything in a list)

ls *.txt //does work

echo $* //nothing since no argument

./a.sh kkjk 1221
prints kkjk 1221 //echo $*: prints out every argument - built in

exit 0 //standard exit
exit

input:
read a
echo a
it will wait for the input: will echo exact same thing

read -p "pleaes input:\n" a //notify the user the program is waiting for the input
echo $a

bash scripting

if ["4" == "5"]
then
echo "true"
fi

if [3 > 25] //gives true:
consider this as string, 3>2 so gives true.
if [3 > 55] //gives true

if [3 -gt 5] //greater than
if [3 -eq 3] //equal to
-gt: greater than
-lt: less than
-ge: greater than or equal
-le: less than or equal
need space

var=3;
var2=4;

if [$var -gt $var2]
then 
  echo "greater"
elif [$var -eq $var2]
then
  echo "equal"
else
  echo "smaller"
fi

find . -type d
directory

-d: to check whether the file is a directory (in bracket)
-f: to check whether the it is a file
-e: if [ -e "../etc" ]: exists

var='ls'
currentdwd='pwd'
for i in $var
do
  if [-e $i ]
  then
    echo $currentd/$i
  fi
done


function t () {
  echo "test"
  echo $1 //first argument
}

t "arg1" "arg2"

function t () {
  echo $#
}

var=$0 //name of the function
t "arg1" "arg2" $var

function t {
  echo $0
  return "return var"
}
echo $t

for i in {1..10}
do
  echo $i
done

echo ${#var} //length of var



Assume Assume Assume
Assume match with ^Assume$
abz match with a.z and a[abc]z
abbz happens with a..z
acz match with a[abc]z
aabcz does not match with a[abc]z
a[^abc]z -> match a.z since complement of ^abc, nothing of abc match
a1z : match with a[0-9]z
to put multiple things, need another bracket
a1dz - for a[0-9][a-z]
use \ to make something unspecial
a[z //match with a\[z
a.z //match with a\.z

a2z : match with a\dz \d: digit
agggggggz match with a[a-g]*z and a[a-g]+z
agggz match with a[a-g]*z and a[a-g]+z
agggbbz match with a[a-g]*z and a[a-g]+z (+: 1+) and a[a-g]{5}z (5 in between)
az match with a[a-g]*z (can have nothing)

agggggggggz : does not match with a[a-g]{5,8}z
aggggggggz : match with a[a-g]{5,8}z

(abc): want to group
abcabcabcabcabc : match with (abc){5} repeat abc 5 times

sed 's/cat/dog/file.txt' replace dog with cat in file.txt
sed "s/b/a" test.txt : change the first occurrence of b to a
sed "s/b/a/g" test.txt : change the all occurrences of b to a

try using ^ and $ option



